## Broken Access Control

- Users access or perform actions beyond their allowed scope
    
- Happens due to over-trusting the frontend or hidden paths
    
- Common in navigation, API routes, and role-based checks
    

### Related Issues

**IDOR (Insecure Direct Object Reference)**

- Exploit: Predictable or exposed URLs like `?user_id=2`
    
- No server-side check if the user owns that ID
    

**Weak Authorization**

- Failure to enforce access restrictions
    
- Example: Accessing admin pages just with a readable cookie like `isadmin=1`
    

**Security Through Obscurity**

- Hiding features ≠ securing them
    
- Attackers easily discover "hidden" paths
    

---

## File Inclusion

- Application includes files based on user input
    
- Risks like Local file inclusion, information disclosure
    

### Practical (DVWA)

- Go to **File Inclusion** tab
    
- Low & Medium security:  
    `?page=/etc/passwd` works → dumps system file
    
- High security:  
    Requires file name to start with **file**, bypass with:  
    `?page=file/../../../../../etc/passwd`
    

---

## File Inclusion Code Examples and Weaknesses

### 1. Low Security (No Filtering)

```php
$file = $_GET['page'];
include($file);
```

**Issue**: Fully controlled by user → LFI, RFI, code execution

---

### 2. Medium Security (Weak Filters)

```php
$file = $_GET['page'];
$file = str_replace(["http://", "https://"], "", $file);
$file = str_replace(["../", "..\\"], "", $file);
include($file);
```

**Issue**: Can be bypassed directly using absolute paths like `/etc/passwd`, which aren't blocked by the filter as it has no `../`.

---

### 3. High Security (Pattern Matching)

```php
$file = $_GET['page'];
if (!fnmatch("file*", $file) && $file != "include.php") {
    echo "ERROR: File not found!";
    exit;
}
include($file);
```

**Issue**: Can be bypassed using nested paths like `file/../../../../../etc/passwd`

---

### 4. Impossible (Whitelist-Based)

```php
$file = $_GET['page'];
if ($file != "include.php" && $file != "file1.php" && $file != "file2.php" && $file != "file3.php") {
    echo "ERROR: File not found!";
    exit;
}
include($file);
```

**Fix**: Proper whitelisting of allowed filenames — safest approach

---

## Key Takeaways

- Broken access control is about missing or weak server-side enforcement
    
- File inclusion must never rely on raw user input
    
- Always validate strictly using whitelists, not pattern filters
    
- Don’t rely on frontend logic or "hidden" paths for security